#!/bin/bash

if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    echo "Using: $0 input_log_file output_log_file <source>"
    echo "Finds the median of the request processing time for the specified source"
    echo "The new file includes requests whose processing time exceeds the median"
    exit 0
fi

if [ "$#" -lt 2 ]; then
    echo "Error: not enough arguments."
    exit 1
fi

input_file="$1"
output_file="$2"
source_filter="$3"

# Фильтрация и сбор времени выполнения
exec_times=() #пустой массив exec_times, который будет использоваться для хранения значений времени выполнения запросов
while IFS='|' read -r level date ip source exec_time; do 
    if [[ -z "$source_filter" || "$source" == "$source_filter" ]]; then
        exec_times+=("$exec_time")
        records+=("$level|$date|$ip|$source|$exec_time") # Сохраняем полную запись
    fi
done < "$input_file"


#while — начало цикла,будет выполняться до пока есть строки для чтения.
#IFS='|' — устанавливает разделитель полей (Internal Field Separator) на символ |.При чтении строки из файла, Bash будет разбивать строку на части по этому символу.
#read читает строку из входного потока (в данном случае — из файла, перенаправленного в цикл) и разбивает ее на переменные:
#level — первая часть (до первого |) #date — вторая часть (между первым и вторым |) #ip — третья часть #source — четвертая чась #exec_time — пятая часть
#-r — опция, которая говорит read не обрабатывать обратные слэши как escape-символы

#-z "$source_filter" — проверяет, является ли переменная source_filter пустой (т.е. не задана).
#|| — логический оператор "ИЛИ"
#"$source" == "$source_filter" — проверяет, совпадает ли значение переменной source со значением переменной source_filter.
#exec_times+=("$exec_time") — добавляет текущее значение времени выполнения (exec_time) в массив exec_times.
#records+=("$level|$date|$ip|$source|$exec_time") — создает строку из всех переменных, разделенных символом |, и добавляет ее в масс records.позволяет сохранить полную запись для дальнейшего использования.
# < "$input_file" — перенаправляет содержимое файла, имя которого хранится в переменной input_file, в стандартный ввод цикла. Это позволяет циклу читать строки из файла.

# Вычисление медианы
count=${#exec_times[@]}
if (( count == 0 )); then
    echo "Нет подходящих записей."
    exit 1
fi

# Сортируем массив для вычисления медианы
sorted_exec_times=($(printf '%s\n' "${exec_times[@]}" | sort -n))
if (( count % 2 == 0 )); then
    median=$(echo "scale=2; (${sorted_exec_times[count/2-1]} + ${sorted_exec_times[count/2]}) / 2" | bc)
else
    median=${sorted_exec_times[count/2]}
fi
#sorted_exec_times=() — инициализация нового массива sorted_exec_times, который будет хранить отсортированные значения.
#printf '%s\n' "${exec_times[@]}" — команда printf выводит каждый элемент массива exec_times на новой строке. 
#'%s\n' — формат строки, где %s означает, что будет выведена строка, а \n добавляет перевод строки после каждого элемента.
#"${exec_times[@]}" — все элементы массива exec_times.
#| — оператор конвейера (pipe)передает вывод одной команды (в данном случае printf) на вход другой команды (в данном случае sort).
#sort -n — сортирует входные строки числовым образом (-n означает "числовая сортировка").важно для правильной сортировки чисел.

#scale=2; — устанавливает количество знаков после запятой на 2 для дальнейших вычислений в bc.
#${sorted_exec_times[count/2-1]} — получает элемент массива sorted_exec_times, соответствующий индексу (count/2 - 1), то есть средний элемент для четного количества.
#${sorted_exec_times[count/2]} — получает следующий элемент массива по индексу (count/2).
#Сложение этих двух значений и деление на 2 дает среднее значение (медиану).
#| bc — передает результат выражения в команду bc, которая выполняет арифметические операции с плавающей точкой.
#median=${sorted_exec_times[count/2]} — присваивает медиане значение сред элемента масс, который соответствует индексу (count/2). Это работает,тк в нечетном количестве элементов существует один центральный элемент.


# Создание выходного файла с записями больше медианы 
> "$output_file" #очищает содержимое файла, указанного в переменной output_file, или создает новый файл, если он не существует. 
for i in "${!exec_times[@]}"; do #возвращает все индексы массива, это индексы exec_times.

    if (( $(echo "${exec_times[i]} > $median" | bc -l) )); then #код проверяет, больше ли текущее значение времени выполнения медианы.
        echo "${records[i]}" >> "$output_file" # добавляет соответствующую запись из массива records (по индексу i) в файл, указанный в переменной output_file ##>> — оператор перенаправления,добавляет вывод команды в конец файла
    fi
done
#echo "${exec_times[i]} > $median" — выводит строку, кот сравнивает текущее значение из массива exec_times (по индексу i) с медианой, сохраненной в переменной median.
# | bc -l — передает эту строку в команду bc, которая выполняет математические операции. Опция -l включает библиотеку математических функций, чтобы работать с числами с плавающей точкой.


echo "Лог-файл создан: $output_file"
echo "Медианное время выполнения: $median"
